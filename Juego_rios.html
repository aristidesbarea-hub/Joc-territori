<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Juego de Ríos - Selección por Punto (Pista Visual)</title>
<style>
    body { display: flex; height: 100vh; margin: 0; font-family: Arial, sans-serif}
    #sidebar {
        width: 250px;
        background: #f9f9f9;
        padding: 10px;
        box-sizing: border-box;
        border-right: 1px solid #ccc;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
    }
    #mapContainer { flex: 1; display: flex; justify-content: center; align-items: flex-start; background: #ddd; }
    svg { border: 1px solid #333; max-width: 95%; max-height: 95%; background: #f2f2f2; }

    .comarca {
        stroke: black;
        stroke-width: 0.5;
        stroke-linejoin: round;
        fill: transparent;
    }

    .river { 
        stroke-width: 2; 
        fill: none; 
        stroke-linecap: round; 
        stroke: #3399ff;
        cursor: default;
        transition: stroke 0.3s;
    }

    .river.hint-active {
        stroke: #4CAF50; 
        stroke-width: 3.5;
    }

    .river-target-point {
        fill: #999;
        r: 6;
        stroke: #333;
        stroke-width: 0.5;
        cursor: pointer;
        transition: fill 0.2s, stroke 0.2s;
    }

    .river-target-point:hover { fill: #666; }

    .river-target-point.correct {
        fill: #32cd32;
        stroke: #1e7e34;
        cursor: default;
    }

    .river-target-point.wrong {
        fill: #dc3545;
        stroke: #bd2130;
    }

    .river-target-point.hint-used {
        fill: #ffc107;
        stroke: #ff9800;
        cursor: default;
    }

    .back-to-menu-btn {
        display: block;
        width: 100%;
        text-align: center;
        padding: 8px 12px;
        font-size: 1em;
        cursor: pointer;
        background-color: #eee;
        border: 1px solid #ccc;
        border-radius: 5px;
        color: #333;
        text-decoration: none;
        transition: background-color 0.2s;
        margin-bottom: 20px;
    }
    .back-to-menu-btn:hover { background-color: #ddd; }

    .target-river-name { 
        font-weight: bold; 
        color: #333; 
        font-size: 1.2em; 
        background-color: #e6f7ff; 
        padding: 10px; 
        border-radius: 5px; 
        text-align: center;
        margin-top: 10px;
        margin-bottom: 20px;
    }

    #riverButtons button { display: none !important; }

    #hintRiversList { margin-top: 5px; padding-left: 20px; }
</style>
</head>
<body>

<div id="sidebar">
    <a href="index.html" class="back-to-menu-btn">← Volver al Menú Principal</a>
    <h2>Juego de Ríos</h2>
    <div style="display: flex; align-items: center; margin-bottom: 10px;">
        <button id="hintButton" style="padding: 6px;">Mostrar Pista</button> 
        <span id="hintText" style="margin-left: 10px; font-weight: bold; color: red;"></span>
    </div>

    <div id="riverButtons"></div>

    <h3>Ríos acertados con pista:</h3>
    <ul id="hintRiversList"></ul>
</div>

<div id="mapContainer">
    <svg viewBox="0 0 800 800">
        <g id="backgroundLayer">
            <image href="MRelieve.png" x="0" y="0" width="800" height="800"></image>
        </g>

        <g id="comarcasLayer"></g>
        <g id="riversLayer"></g> 
        <g id="riverPointsLayer"></g> 
    </svg>
</div>

<script>
let comarcas = [];
let rios = [];
let answeredCorrectPermanent = new Set();
let correctlyAnsweredInSession = new Set();
let riversHintUsedPermanent = new Set();
let targetRiver = null;
let riverPointsMap = new Map();
let riverPolylinesMap = new Map();
let hintUsedForTarget = false;
const X_OFFSET = -100;

const comarcasLayer = document.getElementById('comarcasLayer');
const riversLayer = document.getElementById('riversLayer');
const riverPointsLayer = document.getElementById('riverPointsLayer');
const riverButtonsDiv = document.getElementById('riverButtons');
const hintButton = document.getElementById('hintButton');
const hintText = document.getElementById('hintText');
const hintRiversList = document.getElementById('hintRiversList');

async function loadData() {
    try {
        const timestamp = new Date().getTime();
        const comarcasResponse = await fetch(`comarcas.json?t=${timestamp}`);
        comarcas = await comarcasResponse.json();

        const riosResponse = await fetch(`rios.json?t=${timestamp}`);    
        const dataRios = await riosResponse.json();

        rios = [];
        if (dataRios.rios) {
            dataRios.rios.forEach(r => {
                rios.push(r);
                if (r.afluentes) r.afluentes.forEach(a => rios.push(a));
            });
        }
        initializeGame();
    } catch (error) {
        console.error('Error al cargar los datos:', error);
        if (rios.length > 0) initializeGame();
    }
}

function drawMap() {
    comarcasLayer.innerHTML = "";
    if (comarcas && comarcas.comarcas) {
        comarcas.comarcas.forEach(comarca => {
            comarca.polygons.forEach(polygon => {
                const poly = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
                const pointsStr = polygon.points.map(p => `${p.x},${p.y}`).join(" ");
                poly.setAttribute("points", pointsStr);
                poly.setAttribute("class", "comarca");
                comarcasLayer.appendChild(poly);
            });
        });
    }
}

function drawRiverLines() {
    riversLayer.innerHTML = "";
    riverPolylinesMap.clear();
    if (!rios) return;
    const applyOffset = (p) => `${p[0] + X_OFFSET},${p[1]}`;
    rios.forEach(river => {
        const riverGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
        river.segmentos.forEach(seg => {
            const poly = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
            const pointsStr = seg.puntos.map(applyOffset).join(" ");
            poly.setAttribute("points", pointsStr);
            poly.setAttribute("class", 'river'); 
            riverGroup.appendChild(poly);
        });
        riversLayer.appendChild(riverGroup);
        riverPolylinesMap.set(river.nombre, riverGroup);
    });
}

function drawRiverPoints(reviewMode = false) {
    riverPointsLayer.innerHTML = "";
    riverPointsMap.clear(); 
    rios.forEach(river => {
        const firstSegmentPoints = river.segmentos[0].puntos;
        const p = firstSegmentPoints[Math.floor(firstSegmentPoints.length / 2)];
        const cx = p[0] + X_OFFSET;
        const cy = p[1];

        const point = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        point.setAttribute("cx", cx);
        point.setAttribute("cy", cy);
        point.dataset.riverName = river.nombre;
        point.setAttribute("class", 'river-target-point');

        if (!reviewMode) {
            if (answeredCorrectPermanent.has(river.nombre)) {
                if (riversHintUsedPermanent.has(river.nombre)) {
                    point.classList.add('hint-used');
                } else {
                    point.classList.add('correct');
                }
                point.onclick = null;
            } else {
                point.onclick = (event) => checkAnswer(event.target.dataset.riverName, event.target);
            }
        } else {
            point.onclick = null;
        }

        riverPointsMap.set(river.nombre, point);
        riverPointsLayer.appendChild(point);
    });
    if (!reviewMode) updateHintRiversList();
}

function checkAnswer(clickedRiverName, clickedPoint) {
    if (!targetRiver) return;

    if (clickedRiverName === targetRiver.nombre) {
        answeredCorrectPermanent.add(targetRiver.nombre);
        correctlyAnsweredInSession.add(targetRiver.nombre);

        if (hintUsedForTarget) {
            clickedPoint.classList.add('hint-used');
            riversHintUsedPermanent.add(targetRiver.nombre);
            clickedPoint.dataset.hintUsed = 'true';
            const riverGroup = riverPolylinesMap.get(targetRiver.nombre);
            if (riverGroup) riverGroup.querySelectorAll('.river').forEach(seg => seg.classList.remove('hint-active'));
            updateHintRiversList();
        } else {
            clickedPoint.classList.add('correct');
        }

        clickedPoint.classList.remove('wrong');
        clickedPoint.onclick = null;

        riverPointsMap.forEach(p => p.classList.remove('wrong'));

        setTimeout(() => {
            targetRiver = getRandomRiver();
            hintUsedForTarget = false;
            if (targetRiver) {
                drawRiverPoints();
                updateTargetDisplay();
            }
        }, 1000);
    } else {
        clickedPoint.classList.add('wrong');
    }
}

function getRandomRiver() {
    if (!rios) return null;
    const unans = rios.filter(r => !answeredCorrectPermanent.has(r.nombre));
    if (unans.length === 0) {
        showEndGameOptions();
        return null;
    }
    return unans[Math.floor(Math.random() * unans.length)];
}

function showEndGameOptions() {
    riverButtonsDiv.innerHTML = '';
    const congratsMsg = document.createElement('p');
    congratsMsg.textContent = "¡Felicidades, has acertado todos los ríos!";
    congratsMsg.style.fontWeight = 'bold';
    riverButtonsDiv.appendChild(congratsMsg);

    const restartBtn = document.createElement('button');
    restartBtn.textContent = "Reiniciar";
    restartBtn.className = 'btnRiver';
    restartBtn.style.marginTop = '10px';
    restartBtn.onclick = () => restartGame(false);
    riverButtonsDiv.appendChild(restartBtn);

    const reviewBtn = document.createElement('button');
    reviewBtn.textContent = "Repasar";
    reviewBtn.className = 'btnRiver';
    reviewBtn.onclick = () => restartGame(true);
    riverButtonsDiv.appendChild(reviewBtn);
}

function restartGame(reviewMode) {
    if (reviewMode) {
        answeredCorrectPermanent = new Set(correctlyAnsweredInSession);
    } else {
        answeredCorrectPermanent.clear();
        riversHintUsedPermanent.clear();
    }
    correctlyAnsweredInSession.clear();
    riverButtonsDiv.innerHTML = '';
    riverPointsLayer.innerHTML = '';
    hintText.textContent = '';
    initializeGame(reviewMode);
}

function updateTargetDisplay() {
    riverButtonsDiv.innerHTML = '';
    if (!targetRiver) return;

    const instruction = document.createElement('p');
    instruction.textContent = "Haz clic en el punto del río:";
    riverButtonsDiv.appendChild(instruction);

    const targetName = document.createElement('p');
    targetName.className = 'target-river-name';
    targetName.textContent = targetRiver.nombre.toUpperCase();
    riverButtonsDiv.appendChild(targetName);

    const count = rios.length - answeredCorrectPermanent.size;
    const progress = document.createElement('p');
    progress.textContent = `Ríos restantes: ${count}`;
    progress.style.marginTop = '10px';
    riverButtonsDiv.appendChild(progress);

    hintText.textContent = '';
    hintButton.disabled = false;
}

function giveHint() {
    if (!targetRiver || hintUsedForTarget) return;
    hintText.textContent = targetRiver.nombre.toUpperCase();
    hintUsedForTarget = true;

    const riverGroup = riverPolylinesMap.get(targetRiver.nombre);
    if (riverGroup) riverGroup.querySelectorAll('.river').forEach(seg => seg.classList.add('hint-active'));

    hintButton.disabled = true;
}

function updateHintRiversList() {
    hintRiversList.innerHTML = '';
    riversHintUsedPermanent.forEach(name => {
        const li = document.createElement('li');
        li.textContent = name;
        hintRiversList.appendChild(li);
    });
}

function initializeGame(reviewMode = false) {
    drawMap();
    drawRiverLines();
    targetRiver = getRandomRiver();
    hintUsedForTarget = false;
    if (targetRiver) {
        drawRiverPoints(reviewMode);
        updateTargetDisplay();
    }
    hintButton.onclick = giveHint;
}

loadData();
</script>
</body>
</html>
