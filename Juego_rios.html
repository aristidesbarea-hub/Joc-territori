<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Juego de R√≠os y Ciudades - Identificaci√≥n por Clic</title>
<style>
    body { display: flex; height: 100vh; margin: 0; font-family: Arial, sans-serif}
    #sidebar {
        width: 250px;
        background: #f9f9f9;
        padding: 10px;
        box-sizing: border-box;
        border-right: 1px solid #ccc;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
    }
    #mapContainer { flex: 1; display: flex; justify-content: center; align-items: flex-start; background: #ddd; }
    svg { border: 1px solid #333; max-width: 95%; max-height: 95%; background: #f2f2f2; }
    
    /* Estilos para comarcas */
    .comarca {
        stroke: black;
        stroke-width: 0.5;
        stroke-linejoin: round;
        fill: transparent;
    }
    
    /* === NUEVOS ESTILOS PARA R√çOS INTERACTIVOS === */
    .river { 
        stroke-width: 2; 
        fill: none; 
        stroke-linecap: round; 
        cursor: default;
        transition: stroke 0.3s, stroke-width 0.3s;
    }

    /* R√≠os que son target y a√∫n no han sido acertados */
    .river.initial { 
        stroke: #666; /* Gris oscuro para ser visible pero neutro */
    }
    .river.initial[data-river-name]:hover {
        stroke: #333; /* M√°s oscuro al pasar el rat√≥n para indicar clic */
        stroke-width: 3;
        cursor: pointer;
    }
    
    /* R√≠os ya acertados (Azules) */
    .river.correct { 
        stroke: blue;
        stroke-width: 2.5;
        cursor: default !important;
    } 
    
    /* Respuesta incorrecta (Resaltado breve) */
    .river.wrong { 
        stroke: #ff3333; /* Rojo para error */
        stroke-width: 4;
    }

    /* Pista (Resaltado del objetivo) */
    .river.target-highlight { 
        stroke: red; 
        stroke-width: 3.5;
    }

    /* Estilos para puntos y etiquetas de ciudades (Mantenidos) */
    .city-point {
        pointer-events: none;
        fill: #333;
        r: 2;
    }
    .city-label {
        font-size: 8px;
        font-family: Arial, sans-serif;
        pointer-events: none;
        text-anchor: middle;
        text-shadow:
            -1px -1px 0 #FFF,
            1px -1px 0 #FFF,
            -1px 1px 0 #FFF,
            1px 1px 0 #FFF;
    }
    .city-label.capital {
        font-weight: bold;
        font-size: 10px;
    }

    /* === ESTILOS DEL JUEGO === */
    /* El bot√≥n de hint se mantiene */
    .btnRiver { display: block; width: 100%; padding: 6px; margin: 2px 0; border: 1px solid #ccc; background: #fff; cursor: pointer; text-align: left; }
    
    /* Nuevo estilo para el nombre objetivo */
    .target-river-name { 
        font-weight: bold; 
        color: #333; 
        font-size: 1.2em; 
        background-color: #e6f7ff; 
        padding: 10px; 
        border-radius: 5px; 
        text-align: center;
        margin-top: 10px;
        margin-bottom: 20px;
    }
    #riverButtons button {
        /* Ocultar botones de nombre, ya que ya no se usan */
        display: none !important;
    }

    /* Estilos del bot√≥n de men√∫ */
    .back-to-menu-btn {
        display: block;
        width: 100%;
        text-align: center;
        padding: 8px 12px;
        font-size: 1em;
        cursor: pointer;
        background-color: #eee;
        border: 1px solid #ccc;
        border-radius: 5px;
        color: #333;
        text-decoration: none;
        transition: background-color 0.2s;
        margin-bottom: 20px;
    }
    .back-to-menu-btn:hover {
        background-color: #ddd;
    }
    
</style>
</head>
<body>

<div id="sidebar">
    <a href="../index.html" class="back-to-menu-btn">‚Üê Volver al Men√∫ Principal</a>
    <h2>Juego de R√≠os</h2>
    <div style="display: flex; align-items: center; margin-bottom: 10px;">
        <button id="hintButton" style="padding: 6px;">Mostrar Respuesta</button>
        <span id="hintText" style="margin-left: 10px; font-weight: bold; color: red;"></span>
    </div>
    
    <div id="riverButtons"></div>
</div>

<div id="mapContainer">
    <svg viewBox="0 0 800 800">
        <g id="backgroundLayer">
            <image href="MRelieve.png" x="0" y="0" width="800" height="800"></image>
        </g>

        <g id="comarcasLayer"></g>
        <g id="riversLayer"></g> 
        <g id="cityPointsLayer"></g>
        <g id="citiesLayer"></g>
    </svg>
</div>

<script>
    // Variables de datos
    let comarcas = [];
    let rios = [];
    let originalCiudades = [];
    let ciudadesConCajas = [];
    
    // Variables de juego
    let answeredCorrectPermanent = new Set();
    let correctlyAnsweredInSession = new Set();
    let targetRiver = null;
    
    // VARIABLE DE CORRECCI√ìN HORIZONTAL (DESFASE)
    const X_OFFSET = -100; // Asumo el valor original para el mapa
    
    // Referencias DOM
    const comarcasLayer = document.getElementById('comarcasLayer');
    const riversLayer = document.getElementById('riversLayer');
    const cityPointsLayer = document.getElementById('cityPointsLayer');
    const citiesLayer = document.getElementById('citiesLayer');
    const riverButtonsDiv = document.getElementById('riverButtons');
    const hintButton = document.getElementById('hintButton');
    const hintText = document.getElementById('hintText');
    
    async function loadData() {
        try {
            const timestamp = new Date().getTime();
            const comarcasResponse = await fetch(`comarcas.json?t=${timestamp}`);
            comarcas = await comarcasResponse.json();
            
            const riosResponse = await fetch(`rios.json?t=${timestamp}`);    
            dataRios = await riosResponse.json();

            // Aplanar r√≠os + afluentes en un solo array
            rios = [];
            if (dataRios.rios) {
                dataRios.rios.forEach(r => {
                    rios.push(r); // r√≠o principal
                    if (r.afluentes) {
                        r.afluentes.forEach(a => rios.push(a)); // agregar afluentes
                    }
                });
            }

            const ciudadesResponse = await fetch(`ciudades.json?t=${timestamp}`);
            originalCiudades = await ciudadesResponse.json();
            const cajasResponse = await fetch(`nuevas_posiciones_ciudades_cajas.json?t=${timestamp}`);
            ciudadesConCajas = await cajasResponse.json();

            initializeGame();
        } catch (error) {
            console.error('Error al cargar los datos:', error);
        }
    }

    // Mantenemos drawMap para las comarcas y ciudades
    function drawMap() {
        // Dibujo de comarcas (Sin cambios)
        comarcasLayer.innerHTML = "";
        if (comarcas && comarcas.comarcas) {
            comarcas.comarcas.forEach(comarca => {
                comarca.polygons.forEach(polygon => {
                    const poly = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
                    const pointsStr = polygon.points.map(p => `${p.x},${p.y}`).join(" ");
                    poly.setAttribute("points", pointsStr);
                    poly.setAttribute("class", "comarca");
                    comarcasLayer.appendChild(poly);
                });
            });
        }

        // Dibujo de ciudades (Sin cambios)
        cityPointsLayer.innerHTML = "";
        citiesLayer.innerHTML = "";
        
        if (originalCiudades && originalCiudades.ciudades && ciudadesConCajas && ciudadesConCajas.ciudades) {
            ciudadesConCajas.ciudades.forEach(ciudadConCaja => {
                const ciudadOriginal = originalCiudades.ciudades.find(c => c.nombre === ciudadConCaja.nombre);
                
                if (ciudadOriginal) {
                    // Nota: Los puntos de las ciudades originales tambi√©n deben ser desfasados para alinearse
                    const cityPoint = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    cityPoint.setAttribute("cx", ciudadOriginal.x + X_OFFSET); 
                    cityPoint.setAttribute("cy", ciudadOriginal.y);
                    cityPoint.setAttribute("class", "city-point");
                    cityPointsLayer.appendChild(cityPoint);
                }

                const cityGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
                cityGroup.setAttribute("class", "city-box-group");
                // Nota: Aplicamos X_OFFSET a la posici√≥n de la caja de texto
                cityGroup.setAttribute("transform", `translate(${ciudadConCaja.x + X_OFFSET}, ${ciudadConCaja.y})`); 
                
                const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                text.setAttribute("class", "city-label " + (ciudadConCaja.tipo === 'capital' ? 'capital' : ''));
                cityGroup.appendChild(text);

                citiesLayer.appendChild(cityGroup);
                
                if (ciudadConCaja.lines && ciudadConCaja.lineYOffsets) {
                    drawLinesInRect(text, ciudadConCaja.lines, ciudadConCaja.lineYOffsets, ciudadConCaja.width);
                } else {
                    wrapTextInRect(text, ciudadConCaja.nombre, ciudadConCaja.width);
                }
            });
        }
    }
    
    // Funciones auxiliares para texto (Sin cambios)
    function drawLinesInRect(text, lines, lineYOffsets, width) {
        // ... (c√≥digo sin cambios)
        while (text.firstChild) {
            text.removeChild(text.firstChild);
        }
        const xPos = width / 2;
        lines.forEach((lineText, index) => {
            const tspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
            tspan.setAttribute("x", xPos);
            tspan.setAttribute("y", lineYOffsets[index]);
            tspan.textContent = lineText;
            text.appendChild(tspan);
        });
    }

    function wrapTextInRect(text, fullText, maxWidth) {
        // ... (c√≥digo sin cambios)
        while (text.firstChild) { text.removeChild(text.firstChild); }
        const words = fullText.split(" ");
        let line = "";
        const padding = 10;
        const fontSize = parseFloat(window.getComputedStyle(text).fontSize);
        const lineHeight = fontSize * 1.2;
        const xPos = maxWidth / 2;
        let tspans = [];
        const tempTspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
        text.appendChild(tempTspan);
        for (let i = 0; i < words.length; i++) {
            const testLine = line + (line ? ' ' : '') + words[i];
            tempTspan.textContent = testLine;
            if (tempTspan.getComputedTextLength() > maxWidth - padding) {
                if (line === "") {
                    tspans.push(words[i]);
                } else {
                    tspans.push(line);
                    line = words[i];
                }
            } else {
                line = testLine;
            }
        }
        tspans.push(line);
        text.removeChild(tempTspan);
        
        const totalTextHeight = tspans.length * lineHeight;
        const rectHeight = 20;
        const initialY = (rectHeight / 2) - (totalTextHeight / 2) + (lineHeight / 2) * 0.9;
        
        tspans.forEach((tspanText, index) => {
            const tspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
            tspan.setAttribute("x", xPos);
            tspan.setAttribute("y", initialY + (index * lineHeight));
            tspan.textContent = tspanText;
            text.appendChild(tspan);
        });
    }
    
    // === FUNCIONES DE JUEGO ADAPTADAS ===
    
    function initializeGame() {
        drawMap();
        targetRiver = getRandomRiver();
        if (targetRiver) {
            drawAllRivers('initial'); // Dibujar todos los r√≠os seleccionables
            updateTargetDisplay(); // Mostrar el nombre objetivo
        }
        hintButton.onclick = giveHint;
    }

    function getRandomRiver() {
        if (!rios) return null; 
        const unans = rios.filter(r => !answeredCorrectPermanent.has(r.nombre));
        if (unans.length === 0) {
            showEndGameOptions();
            return null;
        }
        const randomIndex = Math.floor(Math.random() * unans.length);
        return unans[randomIndex];
    }

    function showEndGameOptions() {
        riverButtonsDiv.innerHTML = '';
        const congratsMsg = document.createElement('p');
        congratsMsg.textContent = "¬°Felicidades, has acertado todos los r√≠os!";
        congratsMsg.style.fontWeight = 'bold';
        riverButtonsDiv.appendChild(congratsMsg);
        
        const restartBtn = document.createElement('button');
        restartBtn.textContent = "Reiniciar";
        restartBtn.className = 'btnRiver';
        restartBtn.style.marginTop = '10px';
        restartBtn.onclick = () => restartGame(false);
        riverButtonsDiv.appendChild(restartBtn);
        
        const reviewBtn = document.createElement('button');
        reviewBtn.textContent = "Repasar";
        reviewBtn.className = 'btnRiver';
        reviewBtn.onclick = () => restartGame(true);
        riverButtonsDiv.appendChild(reviewBtn);
    }
    
    function restartGame(reviewMode) {
        if (reviewMode) {
            answeredCorrectPermanent = new Set(correctlyAnsweredInSession);
        } else {
            answeredCorrectPermanent.clear();
        }
        correctlyAnsweredInSession.clear();
        riverButtonsDiv.innerHTML = '';
        riversLayer.innerHTML = '';
        hintText.textContent = '';
        initializeGame();
    }

    // Muestra el nombre del r√≠o a buscar y el progreso
    function updateTargetDisplay() {
        riverButtonsDiv.innerHTML = '';
        if (!targetRiver) return;

        const instruction = document.createElement('p');
        instruction.textContent = "Haz clic en el r√≠o:";
        riverButtonsDiv.appendChild(instruction);

        const targetName = document.createElement('p');
        targetName.className = 'target-river-name';
        targetName.textContent = targetRiver.nombre.toUpperCase();
        riverButtonsDiv.appendChild(targetName);
        
        const count = rios.length - answeredCorrectPermanent.size;
        const progress = document.createElement('p');
        progress.textContent = `R√≠os restantes: ${count}`;
        progress.style.marginTop = '10px';
        riverButtonsDiv.appendChild(progress);

        hintText.textContent = '';
    }

    function giveHint() {
        if (!targetRiver) return;
        
        hintText.textContent = targetRiver.nombre.toUpperCase();
        
        // Redibuja todos los r√≠os, resaltando el objetivo en rojo
        drawAllRivers('target-highlight'); 
        
        // Se a√±ade como acertado para pasar al siguiente
        answeredCorrectPermanent.add(targetRiver.nombre);

        // Espera y pasa al siguiente
        setTimeout(() => {
            targetRiver = getRandomRiver();
            if (targetRiver) {
                updateTargetDisplay();
                drawAllRivers('initial'); // Dibuja el nuevo set de r√≠os
            }
        }, 1500);
    }
    
    // üöÄ FUNCI√ìN CR√çTICA: Dibuja todos los r√≠os y asigna interactividad üöÄ
    function drawAllRivers(mode) {
        riversLayer.innerHTML = "";
        if (!rios) return;

        const applyOffset = (p) => {
          // Aplicamos X_OFFSET a la X
          return `${p[0] + X_OFFSET},${p[1]}`; 
        };

        rios.forEach(river => {
            const isCorrect = answeredCorrectPermanent.has(river.nombre);
            
            let cssClass = '';
            let isInteractive = false;
            
            if (isCorrect) {
                cssClass = 'correct'; // Ya acertados: Azules
            } else if (mode === 'target-highlight' && river.nombre === targetRiver.nombre) {
                cssClass = 'target-highlight'; // Highlight por pista: Rojo
            } else if (mode === 'initial' || mode === 'correct') { 
                // R√≠os que el jugador debe adivinar: Grises y clicables
                cssClass = 'initial';
                isInteractive = true;
            }

            river.segmentos.forEach(seg => {
                const poly = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
                const pointsStr = seg.puntos.map(applyOffset).join(" ");
                
                poly.setAttribute("points", pointsStr);
                poly.setAttribute("class", `river ${cssClass}`);
                
                // **Hacer clicable y guardar el nombre en el elemento**
                if (isInteractive) {
                    poly.dataset.riverName = river.nombre; // Guardar el nombre
                    poly.onclick = (event) => checkAnswer(event.target.dataset.riverName, event.target);
                    poly.style.cursor = 'pointer'; 
                }
                
                riversLayer.appendChild(poly);
            });
        });
    }

    function checkAnswer(clickedRiverName, clickedPolyline) {
        if (!targetRiver) return;
        
        if (clickedRiverName === targetRiver.nombre) {
            
            // Correcto: Marcar y pasar al siguiente
            answeredCorrectPermanent.add(targetRiver.nombre);
            correctlyAnsweredInSession.add(targetRiver.nombre);

            // Redibujar para que el r√≠o acertado se ponga azul (clase 'correct')
            drawAllRivers('correct'); 
            
            setTimeout(() => {
                targetRiver = getRandomRiver();
                if (targetRiver) {
                    updateTargetDisplay(); // Mostrar el nuevo nombre objetivo
                    drawAllRivers('initial'); // Dibujar todos los no acertados en gris
                }
            }, 1000);
        } else {
            // Incorrecto: Resaltar brevemente el trazado clicado
            clickedPolyline.classList.add('wrong');
            setTimeout(() => {
                clickedPolyline.classList.remove('wrong');
            }, 500);
        }
    }

    loadData();
</script>
</body>
</html>
